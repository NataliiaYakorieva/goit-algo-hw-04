# Домашнє завдання 4: Порівняння алгоритмів сортування

## Опис

У цьому завданні порівнюються три алгоритми сортування: злиттям (Merge Sort), вставками (Insertion Sort) та Timsort (вбудований у Python). Для порівняння використано модуль `timeit` на різних наборах даних.

## Файли

- `main.py` — реалізація алгоритмів, тестування, вимірювання часу.
- `readme.md` — опис та висновки.

## Результати тестування

Для масивів розміром 100, 1000, 5000, 10000 елементів було отримано такі результати:


| Розмір масиву | Merge Sort (сек) | Insertion Sort (сек) | Timsort (сек) |
|:-------------:|:----------------:|:--------------------:|:-------------:|
| 100           | 0.00035          | 0.00060              | 0.00002       |
| 1000          | 0.00451          | 0.05091              | 0.00018       |
| 5000          | 0.02208          | —                    | 0.00111       |
| 10000         | 0.04770          | —                    | 0.00247       |

> **Примітка:**  
> Сортування вставками (Insertion Sort) тестується лише на малих масивах (до 1000 елементів), оскільки на великих об'ємах даних цей алгоритм працює надто повільно через квадратичну складність (O(n²)). Тому для розмірів 5000 і 10000 елементів заміри не проводились.

## Висновки

- **Timsort** (вбудований у Python) значно ефективніший за інші алгоритми, особливо на великих масивах.
- **Merge Sort** має складність O(n log n), але поступається Timsort через відсутність оптимізацій для майже відсортованих даних.
- **Insertion Sort** ефективний лише для малих масивів (O(n^2)).
- Поєднання сортування злиттям і вставками у Timsort робить його універсальним і швидким для більшості задач, тому програмісти використовують саме вбудовані функції Python.